## 自我介绍 + 项目介绍


redis相关的：
string 、 hash的底层存储结构

```text
string 简单动态字符串

shah hashtable
```




尽可能避免大key的原因
    根据redis的特性，从以下几个方面分析得到，key的危害：
        1、redis是单线程的（网络IO是线程的，即接受网络请求，但真正处理数据的，还是多线程处理的），所以当查询大key时，网络IO的线程会花更多的时间在该key上，导致处理其他请求不及时
        2、网络带宽：查询大key的数据占用更多的网络带宽，一个时间段的网络带宽时固定的，当这个请求占用的网络带宽足够大的时候，就会影响到其他的请求
        3、大key的失效，可能会造成redis缓存穿透问题
        4、大key失效，影响到redis主线程，糟糕的情况下，会导致redis性能下降

    解决方案：
        1、大key检测 -- 基于redis的检测，触发告警行为
        2、业务拆分大key
        3、代码走查，团队内部宣讲，将其扼杀在摇篮中，避免出现在生产环境中



zset的底层： 跳表表 + 哈希表
    底层的数据结构是跳表： 存储有序数据，跳表为了快速查询，所以维护了多级索引（索引会占用存储空间），基于的思想是二分思想；需要在新增、删除数据时维护索引，不然过期的索引数据会导致查询问题

有点类似小顶堆的那味，但是又不是，因为小顶堆只能拿到最小的数据，而跳表是有序的

zset实现延时队列，延时时间作为分值用于排序，其他信息存放到对应的值中



channel 的底层数据结构：
    环形队列，生产指针，消费指针，锁，等待队列
    当goroutine因为channel阻塞时，goroutine会被阻塞，它会被放到哪里去呢？ 基于GMP模型+channel结构描述
```text
    G、M、P 模型
    
    当goroutine执行到channel被阻塞时，因为这只是一个用户态的阻塞，所以P将G踢出本地队列，将其放入到channel的等待队列中，然后P继续让本地队列中后面的G执行
    当channel中的等待队列中的G达到可运行状态时（channel中有数据，或者有空间，G需要得到cpu时间片才能是运行状态），channel会将等待队列中的G重新放回P的本地队列中

```

项目问题：
数据库分表、业务层面的按照产品分

数据库分表时，业务迁移和数据库双写（双写什么时候取消呢）？


### 算法题

太难了哟
/**
实现一个抢红包的功能，可以设置总金额和总个数，为了使大家都能满意，需保证每个红包的金额都在平均值左右，最大波动范围可以是平均值的一半，红包金额值可以到分。
1. 输入: 总金额 100，总红包数 11
2. 设计多个测试用例，确认程序的正确性，即总金额、总红包数使用多种组合
*/