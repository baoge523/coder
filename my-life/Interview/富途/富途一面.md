
## 面试的整体过程

自我介绍+项目介绍

业务：
 1、如何发现mysql的sql是一个慢sql、怎么去优化的
 2、给了一个sql、问我这个sql有什么问题 -- 从加索引方面、加锁层面
     拓展：
         低基数的字段，加索引有用吗
         uuid的主键索引和自增id的主键索引的区别  -- 从磁盘存储、插入效率层面回答的
         如果一张表没有主键索引      -- 从mysql会使用内部的一个字段属性作为主键回答的
         普通索引和唯一索引的加锁规则   -- gap lock，行锁；遍历到的列和间隙都会加锁，唯一索引再查到值时不会再往下检查、普通索引会再往下检查
         select for update 的使用场景  -- 就是要锁住数据，不让其他事务修改，其他的方式 只说了个表锁；for update是写锁，可以改成读锁 in share model
         mvcc的作用    -- 多版本并发控制，版本的可见性（事务启动的时候，会将所有存活的事务id存放到数组中，同时会根据这些事务id分出一个低水岭和高水岭，比如高水岭还高的事务，就不可见；比低水岭低的可见；如果是在数组中的事务id，不可见，自己的或者不在数组里面的就可见）
                        这里面试官期望听到解决幻读问题，我没有说出来；   undolog、磁盘利用效率-大事务问题，导致很多row版本多，磁盘空间占用多
         undolog的类型 ？？？ 没有回答出来， 只是象征的回答了一点redolog 和 binlog 通过2pc保证一致性

```text
undo log 的模式 ，其实并没有严格意义上面的模式，只是有区分 insert、update/delete 之分

Insert Undo Log：
    在 INSERT 操作中生成、仅对当前事务可见，对其他事务不可见；

Update/Delete Undo Log：
    在 UPDATE 和 DELETE 操作中生成
    用于支持InnoDB 的 多版本并发控制（MVCC）机制，可能需要保留一段时间，待事务提交后放入undo log 链表，等待purge 线程进行最后的清理


Insert undo log 在事务提交后即可回收，而其他操作产生的update/delete undo log 则需要更复杂的生命周期管理，以支持事务的回滚和多版本可见性
```

 3、如果大量请求绕过了redis，直接访问数据库，导致数据库压力过大的原因   -- 考察的是缓冲穿透、redis的ttl集体失效
     解决方式：
        限流（令牌桶）、数据库即便返回空，也会写数据到redis（设置ttl时间）
        紧急处理方式：1、限流、2、手动将热数据导入到redis中
        长期处理方式：随机的redis ttl（打散ttl ）
    --- 后面环节询问时，面试官期望回答到锁控制




算法题
  1、两个携程交替输出abcde 
  2、一颗二叉树，从root节点到叶子节点的流程中构建一个数字，然后求所有组合数字的和
     4 -> 2 -> 7
            -> 8
       -> 1
```text
41 + 428 + 427
```
深度遍历，然后获取到所有的组合的值 --- 但是没有写出来，边界条件没有处理好

```text
思路：
1、深度遍历，组合数据 -- 主要是后插 pre+current
2、深度遍历写数据的条件，是判断当前节点是否是叶子节点，如果是，那么就将记录的数据写入到外部的数组中
3、将外部的数组中的数据转换成数字，然后累加起来
```

智力题：
毒酒问题：1000杯毒酒，其中有一杯是有毒的，喝了之后1个小时就会死亡，给你10只小白鼠，要求在1个小时确定哪一个有毒

考察的是二分思想 ----哎没有做出来，只知道是通过位运算来的 



## 整体感受
面试过程中还是挺不错的，面试了接近2个小时，挺愉快的，但是有很多没有回答到点上，可能没有符合到面试官的预期

面试官是一位小姐姐，说话比较温柔

后面的反问场景，问了一个他们内部在数据一致性上，是强一致还是最终一致

