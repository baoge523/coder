
## 自我介绍 + 项目介绍

主要有一个锁的概念
> linux 的底层
```text
golang 中的sync.Mutex{}锁

内部实现，主要包含了一个state int32，sema  uint32 信号量，用于阻塞和唤醒goroutine

state int32 分不同位表示不同信息：
第0位：表示锁是否被goroutine持有
第1位：表示是否有被唤醒的goroutine
第2位： 表示是否处于饥饿状态
后面的： 表示goroutine的个数

运行状态： 正常状态、饥饿状态
    正常状态：（当前goroutine是等待队列中的最后一个，或者等待队列中的goroutine等待时间不超过1ms）
        新的goroutine会与等待队列的第一个goroutine进行抢锁，谁抢到，谁持有锁 -- 是一种非公平锁的实现方式，在极端情况下，会出现等待队列中的goroutine拿不到锁资源
        
    饥饿状态： （当等待队列中的goroutine存在等待时间超过1ms，进入） -- 是一种公平锁的实现方式
        新的goroutine不抢锁，直接加入等待队列的尾部
        当锁被释放后，锁会之间给队列中的第一个goroutine，不会产生抢锁
        
加锁过程：
    快速方式：尝试直接通过CAS的方式获取锁
    如果失败了，进入慢方式：
        自旋尝试获取锁（4次） -- 一定的次数限制，不能一直自旋，自旋本身是做无用功的方式，消耗cpu资源
        如果失败，那么进入等待队列的尾部
        根据需要切换到饥饿模式（正常模式）

释放锁过程：
    直接释放锁
    如果等待队列中有goroutine：
        正常模式：唤醒下一个等待者（队头的，但是如果此时有新goroutine时，新goroutine会和队头的goroutine抢锁，谁抢到谁占用锁资源）
        饥饿模式：在饥饿模式下直接将锁交给队列头部的goroutine

-----性能优化-----
1、自旋
2、内存屏障：使用原子操作和内存屏障保证内存可见性
3、公平性：（饥饿模式）

------------拓展------------
问题： 在正常模式下，当unlock()释放锁时，如果等待队列中有goroutine，那么会唤醒队头的goroutine，此时有新的goroutine参与抢锁，并抢到了锁，那被唤醒的goroutine又怎么放入到等待队列中呢
答：fifo的方式唤醒，如果唤醒后抢锁失败，那么还是会放到队列头
拓展：这里大部分情况下，如果有新的goroutine抢锁，新goroutine抢到锁的概率更大，因为新的goroutine本身就是在运行中状态（有cpu时间片），而唤醒的goroutine还是可运行状态，需要GMP模型等待调度

问题：为什么允许新 goroutine 抢占？
答：为了提高吞吐量
    新 goroutine 通常正在 CPU 上运行，获取锁后可以立即执行，减少上下文切换
    如果总是让等待队列的 goroutine 优先，可能导致新 goroutine 频繁阻塞，降低并发性能

```

golang怎么实现一个公平锁


锁的等待队列的唤醒机制是什么？
fifo

锁等待队列，chan等待队列，当等待队列中的goroutine被唤醒后，是如何找到P的，通过GMP模型分析
```text
等待队列中的goroutine被唤醒后，会优先找最后一次的p，如果该p本地队列满了，或者不存在了，或者不可中断，就会将其放到全局队列中

g对象中存放了最后一次绑定的p，所以会优先找

等待队列中的goroutine都是通过sudog封装的，sudog有一个g的字段
```

