
### 自我介绍和项目介绍

DDD模式在开发中的运用
```text
1、业务的分层：entity usecase 
2、与传统的mvc开发模式的比较，功能服务更内聚、能更好的评估变更的影响范围
3、常见在开发中的配置类，各个组件使用到的配置entity应该在自己的组件内维护，而不是使用一个统一的config package使用
4、对于访问db的entity类，应该包含所有操作该对应数据的操作，也不是上移到service层（usecase）层，对应的service层应该聚焦在业务逻辑处理
```


golang的map
是否是线程安全的 map sync.Map 其他的map
map 的读写是否存在线程安全问题 
map 的线程不安全体现在哪里


内存泄露如何排查

cpu使用率异常如何排查

火焰图还能排查哪些问题


channel的使用场景：
1、异步任务处理
2、信号通知


数据的表设计
```text
索引设计
主键索引 -- 使用
字段设计
```

数据库的分表设计
```text
用户表： 用户ID
订单表： 订单ID

从用户量级上面（业务场景）考虑，而从考虑如何使用user_id分库还是通过车主id分库
如果想通过车主id查询怎么办，通过另外的索引（车主id-订单id）分表；  什么时候写入呢？ 业务上面双写 --- 可能有不一致的风险，使用2pc、3pc、tcc等方式保证，或者通过最终一致性来保证
提供查询接口，判断是否数据不一致

```

### 编程题，交替打印
妈的，有个死锁问题， 原因是，第二个goroutine没有判断写入channel的条件
```go
nums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

	c1 := make(chan struct{})
	c2 := make(chan struct{})

	w := sync.WaitGroup{}

	w.Add(2)

	go func() {
		defer w.Done()

		for i := 0; i < len(nums); {
			<-c1
			fmt.Printf("%d  ", nums[i])
			c2 <- struct{}{}
			i += 2
		}

	}()

	go func() {
		defer w.Done()

		for i := 1; i < len(nums); {
			<-c2
			fmt.Printf("%d  ", nums[i])
			if i+2 < len(nums) {  // 这里需要判断一下，不然有死锁问题 -- 保证最后一次不发送
				c1 <- struct{}{}
			}
			i += 2
		}

	}()

	// start
	c1 <- struct{}{}
	w.Wait()

	close(c1)
	close(c2)
```

### 反问
乘客端的所有流量入口服务

流量突涨时的处理方式， 限流、水平扩容
业务分表是基于用户id来分表的吗