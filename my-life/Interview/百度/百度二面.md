
## 自我介绍 + 项目介绍


### 可观测的业务
kafka 业务
内部降级服务： 内部是否在业务降级的时候，考虑优先处理紧急的告警，而直接丢弃其他的告警

自监控如何实现的：
   自监控系统

自监控业务指标：
```text
1、请求的指标： 请求错误率、请求成功率、响应时间
2、依赖的外部服务时（http、rpc）请求时，监控成功失败的指标
3、自己请求的请求量
4、业务如果有内部任务，任务的处理时间范围
5、业务如果有用到线程池，那么可以通过包装后，查看线程池的状态，比如等待队列的使用率，线程的使用率
```


### golang基础的

time.sleep()  和 runtime.Gosched() 的区别
```text
time.Sleep()
    将goroutine放入timer的等待队列
```


分析如下：

Golang中的GMP模型应用分析

GMP模型(goroutine调度器模型)是Go语言并发模型的核心，它主要由三部分组成
```text
G (Goroutine)：用户级线程

M (Machine)：操作系统线程

P (Processor)：逻辑处理器，包含运行Go代码的必要资源
```

runtime库中的GMP应用

goroutine调度相关
```text
runtime.GOMAXPROCS(): 设置或查询可以同时执行的最大CPU数，即P的数量

runtime.Goexit(): 终止当前goroutine的执行，GMP模型会处理该goroutine的清理工作

runtime.Gosched(): 让出当前goroutine的执行权，调度器会重新调度其他goroutine
```

系统监控相关
```text
runtime.startTheWorld()和runtime.stopTheWorld(): 控制GMP调度器的启动和停止

runtime.sysmon(): 系统监控线程，负责网络轮询、抢占调度、垃圾回收触发等
```

锁和同步原语
```text
runtime.lock()和runtime.unlock(): 底层锁实现，与GMP调度器协作避免长时间阻塞M

runtime.semacquire()和runtime.semrelease(): 信号量操作，用于同步goroutine
```

time库中的GMP应用
定时器实现
```text
time.NewTimer()和time.After(): 底层使用runtime.timer结构，由GMP模型中的专用goroutinetimeproc管理

time.Sleep(): 通过GMP调度器将当前goroutine挂起，直到时间到期
```




### 算法题
两个链表中找到其相同的节点部分的第一个节点

a[1,2,3,4,5]
b[7,8,9,3,4,5]

思路：
```text
两个指针同时往后移动，直到检测完毕

1、分别将两个链表首尾相连，a-b； b-a
2、分别遍历，然后判断是否值相同，如果在遍历完之前有相同的，那么就存在，否则就不存在了
```