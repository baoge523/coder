## 开发规范

### git相关的规范
项目多人协作开发项目，一般项目仓库是一个公共的仓库；我们需要先将公共仓库fork到自己的工作空间下，此时自己空间下就有一个一模一样的仓库了，然后再在自己的仓库中创建开发分支，就行研发验证
和github的开发方式保持一致即可

git的提交规范：
[commit_message](https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#commit-message-format)
```text
feat: A new feature   新特性
fix: A bug fix     修复bug
docs: Documentation only changes   修改文档
style: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)  不变更逻辑，只修改代码风格，规范
refactor: A code change that neither fixes a bug nor adds a feature   重构代码，只不是修复bug和新特性开发的代码
perf: A code change that improves performance    优化性能的代码
test: Adding missing or correcting existing tests   补全测试用例的代码、修改测试用例的代码
chore: Changes to the build process or auxiliary tools and libraries such as documentation generation   流水线、工具、等变更
```

### golang的开发规范
[Go Code Review Comments](https://go.dev/wiki/CodeReviewComments)
[CodeReviewComments](https://github.com/golang/go/wiki/CodeReviewComments)
[decisions](https://google.github.io/styleguide/go/decisions)


[effective_go](https://go.dev/doc/effective_go#errors)


### 代码架构
[The Clean Architecture:](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)

entity
```text
定义数据实体类，即数据相关的装换
```

repoimpl  依赖与entity
```text
面相接口编程

数据操作接口 -- 从数据库中获取哪些数据

数据操作接口实现

```

usecase： 依赖与 entity、repoimpl
```text
处理具体的业务逻辑：
1、定义业务对外暴露得功能接口
2、实现该功能接口
```

pkg/xxx 独立的模版，主要服务与业务，但又和业务无关的
```text
比如：
1、kafka的producer、consumer 的保证，指定了如何创建一个producer、consumer，并且提供了一些监控、自管理功能

```


### metric 指标上报
pkg/telemetry
[otel](https://github.com/open-telemetry/opentelemetry-go)

标签的类型引用 otel/attribute ，在某些语义上可以直接复用 otel/semconv ;方便与 otel 对接和后续的整合演进
[otel/attribut](http://pkg.go.dev/go.opentelemetry.io/otel/attribute)
[otel/semconv](https://pkg.go.dev/go.opentelemetry.io/otel/semconv)


### 提供一个分布式场景下多节点协调的能力
pkg/masternode

### 提供业务场景下常见的协程池使用封装，并提供一致的可观测实现
pkg/workerpool

pkg/gdticker

### 数据库设计
对外ID和自增id需要区分开

对外ID,比如xxxID
内部自增id，会随着分库分表而改变

### 内聚
将操作一个struct相关的func、method、config 等，都内聚到实体类中；遵循DDD开发模式

核心定义：
指标 + 维度 + (聚合) = 计量

计量可以是直接上报聚合的基础，比如5s上报一次，将5s的上报数据看出一个基础的计量
维度在其中的作用是：补全产品侧上报时，没有携带的信息，比如，实例上报时，其实实例自己不知道自己属于哪个用户的，所以需要维度补全维度信息
可以选的聚合的作用是：计量可以是基础的信息，比如产品侧上报的指标5s的数据，但是很多情况是不满足用户的使用的，用户需要1分钟、5分钟、15分钟、1小时、2小时等，这些就可以之前基础计量聚合而来

计量的作用：计量作为了数据源的基础单位，可以通过自身聚合得到更多的计量，比如根据一分钟的计量 聚合 得到一小时的计量； 多个某两个维度的计量 聚合后，得到组合计量；
        同时计量中封装了指标、维度、也有具体的计算得到的数据，当使用侧，需要具体的指标数据时，就可以通过维度信息，查询计量中的指定指标的数据


### 数据流
https://github.com/influxdata/influxql/blob/master/ast.go#L412


### 编码技巧
1、对于背景任务中出现的可容忍的错误，也需要通过一些可观察的行为，使其留下痕迹方便排查定位问题，比如：日志、指标上报，其他的可观测行为
2、当业务在main函数中进行初始化是，某个业务服务，初始化后，应该有cleanup等类似的函数
```golang
  serviceA,cleanup,err := initService()
  defer cleanup()
```
3、方法的单测覆盖率 --- 重要
4、rpc中，通过pb生成的struct，应该使用getxxx的方式获取内部属性，这样即使内部属性为nil，也不会有panic

### prometheus
https://prometheus.io/docs/prometheus/latest/querying/remote_read_api/

### 梳理一下场景，golang在哪些场景下会有panic --- 主要针对sdk相关的，而不是用户定义的

### gorm.db 创建的query不要重复实现，会携带上次的query的where条件

### golang切片问题
https://juejin.cn/post/7064938788824285215
就是通过slice 索引或者append创建出来的新切片可能会复用相同的地址空间，这样会导致修改一个切片却影响到了其他的切片
```golang
 s1 := []int{1, 2, 3}
    s2 := s1[1:2]
    s3: = append(s2, 10)

// s1 1 2 10
// s2 2
// s3 2 10
```
