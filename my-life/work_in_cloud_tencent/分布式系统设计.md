

https://raft.github.io/

mysql半同步
https://dev.mysql.com/doc/refman/8.0/en/replication-semisync.html

## 分布式系统设计


在微服务架构设计中，将一个大而全的服务，按照其功能拆分成不同的服务，服务直接通过网络的方式访问，通常是http、rpc等

拆分成微服务的优缺点

优点:
 - 服务功能单一，符合单一原则
 - 功能变更时，只需要升级对应的服务即可，不需要升级整体
 - 

缺点:
 - 拆分后的服务基于网络访问，效率比内存访问低100倍
 - 存在网络问题
 - 服务拆分过多，维护比较困难，比如服务发现、服务注册、服务寻址、服务熔断与降级
 - 数据一致性问题的保证


### 在分布式下，数据一致性成为一个业务困难点

数据一致性的方案：
- 强一致性
- 弱一致性
- 最终一致性

强一致性： 在业务功能中，每时每刻都是一致性
弱一致性  不保证，数据是一致性的
最终一致性，是一个弱一致性的实现，表示在经过一段时间后，在某一时刻后，数据最终是一致的

保证一致性的方式有哪些：
- 2PC
- 3PC
- TCC 阿里的

2pc
```text

```

3pc
```text

```

tcc
```text
TCC的定义

Try: 尝试执行业务

完成所有业务检查（一致性）
预留必须业务资源（准隔离性）
Confirm: 确认执行业务

真正执行业务
不作任何业务检查
只使用Try阶段预留的业务资源
Confirm操作满足幂等性

Cancel: 取消执行业务

释放Try阶段预留的业务资源
Cancel操作满足幂等性
```

CAP理论
```text
一个经典的分布式系统理论。CAP理论告诉我们：一个分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition tolerance）这三个基本需求，最多只能同时满足其中两项。

1、一致性

对于一个将数据副本分布在不同分布式节点上的系统来说，如果对第一个节点的数据进行了更新操作并且更新成功后，却没有使得第二个节点上的数据得到相应的更新，于是在对第二个节点的数据进行读取操作时，获取的依然是老数据（或称为脏数据），这就是典型的分布式数据不一致的情况。**在分布式系统中，如果能够做到针对一个数据项的更新操作执行成功后，所有的用户都可以读取到其最新的值，那么这样的系统就被认为具有强一致性**。

对于多个节点配合才能完成的操作，所有参与这个操作的节点的数据变动应该是同步的。

2、可用性

可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够**在有限的时间内返回结果**。这里的重点是"有限时间内"和"返回结果"。

"有限时间内"是指，对于用户的一个操作请求，系统必须能够在指定的时间内返回对应的处理结果，如果超过了这个时间范围，那么系统就被认为是不可用的。另外，"有限的时间内"是指系统设计之初就设计好的运行指标，通常不同系统之间有很大的不同，无论如何，对于用户请求，系统必须存在一个合理的响应时间，否则用户便会对系统感到失望。

"返回结果"是可用性的另一个非常重要的指标，它要求系统在完成对用户请求的处理后，返回一个正常的响应结果。正常的响应结果通常能够明确地反映出队请求的处理结果，即成功或失败，而不是一个让用户感到困惑的返回结果。

3、分区容忍性

分区容忍性约束了一个分布式系统具有如下特性：分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。
```

选择	说明
CA	放弃分区容忍性，加强一致性和可用性，其实就是传统的单机数据库的选择
AP	放弃一致性（这里说的一致性是强一致性），追求分区容忍性和可用性，这是很多分布式系统设计时的选择，例如很多NoSQL系统就是如此
CP	放弃可用性，追求一致性和分区容忍性，基本不会选择，网络问题会直接让整个系统不可用

BASE理论
```text
BASE是Basically Available（基本可用）、
Soft state（软状态）和Eventually consistent（最终一致性）三个短语的缩写。
BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的。
BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性
```


### 最终一致性的保证的方式
除了像2pc、3pc、tcc等模式，可以保证强一致性外，还可以使用以下方式来保证最终一致性

查询模式：
```text
任何一个服务操作都需要提供一个查询接口，用来向外部输出操作执行的状态。服务操作的使用方可以通过查询接口，得知服务操作执行的状态，然后根据不同状态来做不同的处理操作


简单理解就是： 通过流水ID查询到各个服务模块处理的结果信息，从而根据结果信息判断是否需要通过"补偿方式"来保证最终一致性

单个查询
批量查询（需要分页）
```

补偿模式：
```text
有了上面的查询模式，在任何情况下，我们都能得知具体的操作所处的状态，如果整个操作处于不正常的状态，我们需要修正操作中有问题的子操作，
这可能需要重新执行未完成的子操作，或者取消已经完成的子操作，通过修复使整个分布式系统达到一致，为了让系统最终一致而做的努力都叫做补偿


1. 自动恢复：程序根据发生不一致的环境，通过继续未完成的操作，或者回滚已经完成的操作，自动来达到一致
2. 通知运营：如果程序无法自动恢复，并且设计时考虑到了不一致的场景，可以提供运营功能，通过运营手工进行补偿
3. 通知技术：如果很不巧，系统无法自动回复，又没有运营功能，那必须通过技术手段来解决，技术手段包括走数据库变更或者代码变更来解决，这是最糟的一种场景
```


本地消息表
```text
通过创建一张本地消息表记录数据，该数据会在同一个本地事务(A服务事务)中提交，本地消息表中的数据会写入到kafka中，kafka中的数据会被服务B消费(失败时可以重试几次)，重试几次后还失败，就发送通知给服务A让其逆向操作(伪回滚操作)

生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。
```


MQ事务消息

### 分布式事务架构设计


在分布式中，事务反查很重要，当由于网络分区、机器故障重启(failover)后，重新执行事务时，可能通过事务反查，看事务查询到哪个阶段(有执行记录的就不执行)，直接执行后面的阶段



理解一个事物的执行，主要分两个部分
 - 有逻辑失败的情况，再怎么重试也都会失败，比如给用户扣款100元，但是用户的账户只有10元，再怎么重试都会失败
 - 无逻辑失败的情况，比如因为网络、硬件等，只需要一直重试，直到成功为止

📢注意： 其实一直没有搞懂，怎么可以将一个事物拆分成多个块，然后分段处理呢


将主事务和从事务异步结构的方式：
1、同步执行主事务(多个主事务，参考下面的方案)
2、异步执行从事务


多个主事务的方案：

多个主事务串行执行时，比如事务A成功，事务B失败，(回滚麻烦)那么就执行事务A的逆向操作，但是这里有一个问题是：存在短暂的中间状态暴露给用户，比如用户的增额，多了100元；同时在这期间，又有可能被用户花出去
> 处理的方式：尽可能将这种事务放到最后执行

TCC 方案比较复杂，人工成本大

事务预写：
> 将事务中可能存在有逻辑失败的部分，放到事务预写阶段，即在prepare写入事件中心之前；
