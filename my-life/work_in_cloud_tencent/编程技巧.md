
### 一个服务是需要监听系统的signal(信号量)来做一些优雅退出操作的
1、需要判断自己使用的框架的架构中是否有监听操作系统的信号量来做优雅退出
```golang
// trpc就有做监听系统退出signal
import (
"os/signal"
"golang.org/x/sys/unix"
)

// 业务初始化操作完成，

// 注册，并监听操作系统的信号量
signal.Notify(s.signalCh, unix.SIGINT, unix.SIGTERM, unix.SIGSEGV)

// 阻塞等着在这里
select {
case <-s.closeCh:
case <-s.signalCh:
	// do something
}

// 接收到系统的退出信号量，执行优雅关闭操作

```
2、如果没有，就需要自己在服务系统中监听一下系统的退出信号量
```golang
import (
"syscall"  // unix
)

signal.Notify(signalsChannel, syscall.SIGHUP, syscall.SIGTERM)

// 监听 signalsChannel --- 可以异步监听，然后调用服务的close方法，优雅关闭服务
```

### 如何实现一个读取配置文件的框架信息
1、自定义配置的结构体
2、通过loaderFactory 创建出loader，同时指定配置的结构体(可以携带默认值，如果配置中有就覆盖默认值)
3、loader.start() --> 底层就是调用具体的配置加载器，去加载配置，同时判断是否需要动态监听配置
4、获取配置，不能直接返回配置对象；而是在需要使用配置的时候，通过func调用动态获取；运行时获取 --- 重要


```text
yaml.v3@v3.0.1

// 将u的值，Unmarshal 成 i 结构体
yaml.Unmarshal([]byte(u.Value()), i)

// 匿名函数 -- golang 中经常使用匿名函数的，需要习惯
func (i interface) error {
    return yaml.Unmarshal([]byte(u.Value()), i)
}
```
### sync.pool的使用场景
sync.pool主要是用于复用对象(复用内存)；基于复用对象的方式，减少频繁的创建对象(内存分配)；减少gc

场景：
 - 用于读取io.body中的数据的buffer(bytes.NewBuffer(make([]byte, 0, initial)))

### json工具
json解析
```text
github.com/json-iterator/go@v1.1.12
jsoniter.Unmarshal(buffer.Bytes(), &records)
```

### 业务处理数据时，数据入口处
1、数据尽可能的结构化
2、不能结构化的数据来源方需要确认原因，如果是新增的，那么就尽可能满足结构化；如果是遗留的，需要分类兼容一下
3、检查数据的合法性， -- 兼容性判断，根据不同的策略就行操作， 比如数据没有值时，是补充默认值，还是直接丢弃，还是其他的处理

### 通过工厂方法创建对应的对象时，如果对象的配置存在必填、选填等配置时，可以通过option的方式，以闭包的行为在使用时，动态的注入进去
```golang
func NewFactory(
	cfgType Type,
	config Config,
	options ...FactoryOption,
) Factory {
	f := &factory{
		cfgType:                 cfgType,
		CreateDefaultConfigFunc: createDefaultConfig,
	}
	// FactoryOption 是一个个闭包函数，里面有applyOption方法，将闭包中的数据设置到f这个配置中
	for _, opt := range options {
		opt.applyOption(f)
	}
	return f
}
```

### kafka-go的使用
```text
github.com/segmentio/kafka-go@v0.4.47

WriteMessages(ctx context.Context, msgs ...Message)
```

### 根据数据的流向，将数据处理分为：接收器、处理器、输出器
接收器: receiver 、source
处理器: processor
输出器: sink、exporter

上面的组件都有自己的生命周期管理，比如启动、销毁；所以可以定义一个公共的接口 component interface 其中定义了start stop(shutdown)接口

细节：--- 重要
```text
1、每个组件都有自己的业务逻辑处理细节，但是正常情况下避免日志爆炸，所以我们只会输出流程日志，对一些细节性的日志不太关系
2、但是当我们发现组件存在问题时，此时需要查看更多的日志细节，所以我们可以通过开启在组件中的埋点日志，比如debug、trace级别的日志


这个很重要，在日常开发中，我们只关心了正常的情况的日志，且也没有通过不同的日志级别输出日志，这样就会造成两种极端的问题（日常开发都是info级别的日志）
1、日志输出很详细，都是info级别的；当出现异常情况还好可以基于这些日志排查问题，但是正常情况(理论上99%以上的时间)日志爆炸，磁盘很多就被打满，造成其他的一些意外情况
2、没有关键日志输出，当业务发现问题时，通过日志定位问题，发现通过日志无法定位到哪个组件，或者组件内哪个部分出现了问题；于是就只能修改代码添加关键日志；费时费力，关键是有的环境不轻易让替换版本
```

管理侧的接口：修改日志级别，内部管理

可以在各个组件中定义日志级别，并可以设置日志级别，并在设置后，定时关闭(防止忘记将日志级别改回去)
```go
// Debugger debugger通用接口
type Debugger interface {
	SwitchDebug(flag bool)
	SwitchTrace(flag bool)
}

// Component 实现了Debugger接口的通用组件
type Component struct {
	cancel context.CancelFunc
	Debug  bool
	Trace  bool
}
```
Component 实现了Debugger接口，可以启动、关闭debug、trace级别的日志
所有的组件，都是组合了Component，可以实现动态开关的能力

### 文本编解码
```go
// TextMarshaler is the interface implemented by an object that can
// marshal itself into a textual form.
//
// MarshalText encodes the receiver into UTF-8-encoded text and returns the result.
type TextMarshaler interface {
	MarshalText() (text []byte, err error)
}

// TextUnmarshaler is the interface implemented by an object that can
// unmarshal a textual representation of itself.
//
// UnmarshalText must be able to decode the form generated by MarshalText.
// UnmarshalText must copy the text if it wishes to retain the text
// after returning.
type TextUnmarshaler interface {
	UnmarshalText(text []byte) error
}
```

### 数据的传输，需要考虑压缩和序列化
压缩：减少数据大小，提高传输效率，降低带宽消耗，缩短传输时间  -- Gzip，LZ4，Zstandard (Zstd)
序列化: 将数据结构转换成可传输的数据格式，使其能够在不同的系统直接传输和重建；保证数据的完整性和一致性 -- proto，json

场景：
1、网络传输，比如rpc的数据传输中，可以先使用序列化，然后再压缩
2、内部数据流转场景，比如producer\consumer模式的数据传输，可以只使用序列化

序列化操作
```go
// proto序列化
"google.golang.org/protobuf/proto"
proto.Marshal(&pb.MetricList{
		Namespace: ns,
		Metrics:   metrics,
	})

// json 序列化
"encoding/json"
json.Marshal(&pb.MetricList{
    Namespace: ns,
    Metrics:   metrics,
})

```

### prometheus 的使用
一般常见的监控的是：
 - gauge   仪表盘
 - counter  数量值
 - histogram  柱状图

gauge
```go
// 声明
	gauge := prometheus.NewGaugeVec(prometheus.GaugeOpts{
		Namespace:   namespace, // full name = namespace_subsystem_name
		Name:        name,
		ConstLabels: map[string]string{}, // 常量labels信息，比如 "code":200,所有的都默认加上，根据场景指定常量labels
	}, labels) // labels 监控的维度
	
	// 注册指标到prom中
	prometheus.MustRegister(gauge)
	
// 使用
gauge.WithLabelValues(labels...).Set(v)
```
counter
```go
// 声明
	counter := prometheus.NewCounterVec(prometheus.CounterOpts{
		Namespace:   namespace,
		Name:        name,
		ConstLabels: map[string]string{},
	}, labels)  // 这里的labels是key
	prometheus.MustRegister(counter)
	
// 使用
counter.WithLabelValues(labels...).Add(float64(v))  // 这里的labels是value，与定义的时候对应
counter.WithLabelValues(labels...).Inc()            // 这里的labels是value，与定义的时候对应
	
```
histogram
```go
// 声明
    histogram := prometheus.NewHistogramVec(prometheus.HistogramOpts{
        Namespace:   namespace,
        Name:        name,
        ConstLabels: map[string]string{},
        Buckets:     buckets,
	}, labels)
    prometheus.MustRegister(histogram)
	
// 使用
histogram.WithLabelValues(labels...).Observe(v)
```

### go gin middleware


### options 模式开发，一般用于可选的配置项操作
1、定义个配置struct，该struct里面包含多个配置项
2、定义一个option方法，该方法的入参就是定义的配置struct
3、提供入参是配置项，且出参是option方法的func，这些func用于动态调用时，向配置struct设置配置项
4、定义一个执行func，该func用于将配置项设置到配置struct中 -- 这个可以根据情况而定

具体实现如下:
```go
// NewOptions 新建统计对象时候的参数
type NewOptions struct {
	Description string         // 配置项1
	Buckets     []float64      // 配置项2
	Policy      GaugeAggPolicy // 配置项3
}

// Apply 执行修改函数；执行配置项func，将设置配置
func (o *NewOptions) Apply(f ...NewOption) {
	for _, currFun := range f {
		currFun(o)
	}
}

// NewOption 设置参数
type NewOption func(*NewOptions)

func WithDescription(d string) NewOption {
	return func(no *NewOptions) {
		no.Description = d
	}
}

func WithBuckets(b []float64) NewOption {
	return func(no *NewOptions) {
		no.Buckets = b
	}
}

func WithAggPolicy(p GaugeAggPolicy) NewOption {
	return func(no *NewOptions) {
		no.Policy = p
	}
}

```

### 可观测： 指标、日志(不同级别的日志)
在应用开发中，正常的思维时，只关系自己的业务功能代码，这样程序是可以正常跑起来，但是我们无法看到程序的内部运行情况，
只能通过一些linux的性能查询工具来判断应用是否正常，比如通过ps,netstat,pid,top,
或者一些语言体统的性能查询工具，比如gops,pprof等等，但这些工具查询的又是和业务无关信息的

总之: 没有可观测的应用系统，就相当于在裸奔

监控指标统计方式：
  - count  总数 只增不减
  - gauge  仪表盘  可增可减
  - histogram 柱状图 

监控指标，可以参考golang中的实现库otel
```text
指标定义：https://pkg.go.dev/go.opentelemetry.io/otel/attribute
opentelemetry语义: https://pkg.go.dev/go.opentelemetry.io/otel@v1.37.0/semconv/v1.11.0
```

应用场景:
```text
请求成功数量
请求失败数量
连接失败数量
响应时间柱状图
```

业务场景：
> 市面上可选的监控系统比如多，为了提供系统的健壮性，将系统可能用到的监控统计方式抽离成接口的方式，与底层真正的业务实现分离；以达到面向接口编程、动态可插拔效果
> 比如底层正在实现是：prometheus、获取内部一些监控系统

内部接口定义，屏蔽实现细节 api/metric
```go

```