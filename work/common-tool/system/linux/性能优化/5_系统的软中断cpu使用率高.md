## linux的软中断
如何定位是linux的软中断cpu使用率高？
发现是linux的软中断cpu使用率高后，我该怎么修复它呢？

### 什么是中断，为什么要有中断？
中断是系统用来响应硬件设备请求的一种机制，它会打断进程的正常调度和执行，然后调用内核中的中断处理程序来响应设备的请求。

中断其实是一种异步的事件处理机制，可以提高系统的并发处理能力。

由于中断处理程序会打断其他进程的运行，所以，为了减少对正常进程运行调度的影响，中断处理程序就需要尽可能快地运行。

#### 以点外卖的方式来理解中断
```text

假设你在某平台上面点了外卖，该平台的特色是：如果送达的时候，你不在，那么外卖员会立马走掉，送下家去；而对你来说就会失去外卖

所以你只能时不时在门口等着，而不能自由的去干其他的事情，因为你担心会失去外卖

但是如果你在定外卖的时候，和外卖员商量好，当外卖送达时给你打一个打电话通知你（这个打电话就相当于中断）；此时你就可以安心的干其他的事情，而不用担心失去外卖

但是打电话(中断)这个行为，必须短小精干（很快执行完那种）

比如：你在某平台上面点了两份外卖，分别由两位配送员配送，但a到时，给你打了一个长长的电话（比如商量售后问题等等），b到时，给你打电话发现你的手机占线了，于是b转头就走了

因此你也失去了外卖b
```

### 怎么理解linux中的软中断

为了解决中断处理程序执行过长和中断丢失的问题，Linux 将中断处理过程分成了两个阶段，也就是上半部和下半部：

- 上半部用来快速处理中断，它在中断禁止模式下运行，主要处理跟硬件紧密相关的或时间敏感的工作。
- 下半部用来延迟处理上半部未完成的工作，通常以内核线程的方式运行。

```text
比如说前面取外卖的例子，上半部就是你接听电话，告诉配送员你已经知道了，其他事儿见面再说，然后电话就可以挂断了；下半部才是取外卖的动作，以及见面后商量发票处理的动作。
这样，第一个配送员不会占用你太多时间，当第二个配送员过来时，照样能正常打通你的电话。
```

#### 网卡接收数据包的例子
网卡接收到数据包后，会通过硬件中断的方式，通知内核有新的数据到了；

这时，内核就应该调用中断处理程序来响应它

```text
对上半部来说，既然是快速处理: 
  其实就是要把网卡的数据读到内存中，然后更新一下硬件寄存器的状态（表示数据已经读好了），最后再发送一个软中断信号，通知下半部做进一步的处理。

而下半部被软中断信号唤醒后:
  需要从内存中找到网络数据，再按照网络协议栈，对数据进行逐层解析和处理，直到把它送给应用程序。
```
- 上半部直接处理硬件请求，也就是我们常说的硬中断，特点是快速执行；
- 而下半部则是由内核触发，也就是我们常说的软中断，特点是延迟执行。

实际上，上半部会打断 CPU 正在执行的任务，然后立即执行中断处理程序。
而下半部以内核线程的方式执行，并且**每个 CPU 都对应一个软中断内核线程**，名字为 “ksoftirqd/CPU 编号”，比如说， 0 号 CPU 对应的软中断内核线程的名字就是 ksoftirqd/0。

#### 查看软中断和内核线程
 - /proc/softirqs 提供了软中断的运行情况；
 - /proc/interrupts 提供了硬中断的运行情况。
```text
$ cat /proc/softirqs
                    CPU0       CPU1
          HI:          0          0
       TIMER:     811613    1972736
      NET_TX:         49          7
      NET_RX:    1136736    1506885
       BLOCK:          0          0
    IRQ_POLL:          0          0
     TASKLET:     304787       3691
       SCHED:     689718    1897539
     HRTIMER:          0          0
         RCU:    1330771    1354737

```
第一，要注意软中断的类型，也就是这个界面中第一列的内容。
第二，要注意同一种软中断在不同 CPU 上的分布情况，也就是同一行的内容。

软中断实际上是以内核线程的方式运行的，每个 CPU 都对应一个软中断内核线程，这个软中断内核线程就叫做  ksoftirqd/CPU 编号。那要怎么查看这些线程的运行状况呢？
```text
$ ps aux | grep softirq
root         7  0.0  0.0      0     0 ?        S    Oct10   0:01 [ksoftirqd/0]
root        16  0.0  0.0      0     0 ?        S    Oct10   0:01 [ksoftirqd/1]

```
一般来说，ps  的输出中，名字括在中括号里的，一般都是内核线程。

### 系统的软中断CPU使用率升高，我该怎么办？

复习中断：
```text
中断是一种异步的事件处理机制，用来提高系统的并发处理能力。
中断事件发生，会触发执行中断处理程序，而中断处理程序被分为上半部和下半部这两个部分。

    上半部对应硬中断，用来快速处理中断；
    下半部对应软中断，用来异步处理上半部未完成的工作。

Linux 中的软中断包括网络收发、定时、调度、RCU 锁等各种类型，
我们可以查看 proc 文件系统中的 /proc/softirqs  ，观察软中断的运行情况。

在 Linux 中，每个 CPU 都对应一个软中断内核线程，名字是 ksoftirqd/CPU 编号。
当软中断事件的频率过高时，内核线程也会因为 CPU 使用率过高而导致软中断处理不及时，
进而引发网络收发延迟、调度缓慢等性能问题。
```

软中断类型有哪些
```text
可以查看/proc/softirqs 里面的信息
```

#### 定位排查软中断cpu的使用率高的问题

##### 工具信息
- sar 是一个系统活动报告工具，既可以实时查看系统的当前活动，又可以配置保存和报告历史统计数据。
- hping3 是一个可以构造 TCP/IP 协议数据包的工具，可以对系统进行安全审计、防火墙测试等。
- tcpdump 是一个常用的网络抓包工具，常用来分析各种网络问题。

```text
hping3的使用：

# -S参数表示设置TCP协议的SYN（同步序列号），-p表示目的端口为80
# -i u100表示每隔100微秒发送一个网络帧
# 注：如果你在实践过程中现象不明显，可以尝试把100调小，比如调成10甚至1
$ hping3 -S -p 80 -i u100 192.168.0.30


```

##### 排查定位软中断的过程
1、通过top命令查看进程资源使用情况
> 发现top的展现信息都是正常的、平均负载都是0，cpu使用也不高、没有僵尸进程、没有不可中断进程；但发现在使用的cpu几乎都在软中断上，
猜测可能是软中断出现的了问题

2、查看软中断信息：proc/sortirqs
但是proc/sortirqs是开机以来的各种软中断的总数，不能体现变化率，所以使用watch来查看
```text
$ watch -d cat /proc/softirqs
                    CPU0       CPU1
          HI:          0          0
       TIMER:    1083906    2368646
      NET_TX:         53          9
      NET_RX:    1550643    1916776
       BLOCK:          0          0
    IRQ_POLL:          0          0
     TASKLET:     333637       3930
       SCHED:     963675    2293171
     HRTIMER:          0          0
         RCU:    1542111    1590625

```
通过 /proc/softirqs 文件内容的变化情况，你可以发现， TIMER（定时中断）、NET_RX（网络接收）、SCHED（内核调度）、RCU（RCU 锁）等这几个软中断都在不停变化。

其中，NET_RX，也就是网络数据包接收软中断的变化速率最快。

3、sar 用来查看系统的网络收发情况
> 不仅可以观察网络收发的吞吐量（BPS，每秒收发的字节数），还可以观察网络收发的 PPS，即每秒收发的网络帧数。
```text
# -n DEV 表示显示网络收发的报告，间隔1秒输出一组数据
$ sar -n DEV 1
15:03:46        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil
15:03:47         eth0  12607.00   6304.00    664.86    358.11      0.00      0.00      0.00      0.01
15:03:47      docker0   6302.00  12604.00    270.79    664.66      0.00      0.00      0.00      0.00
15:03:47           lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
15:03:47    veth9f6bbcd   6302.00  12604.00    356.95    664.66      0.00      0.00      0.00      0.05

```
 - 第一列：表示报告的时间。
 - 第二列：IFACE 表示网卡。
 - 第三、四列：rxpck/s 和 txpck/s 分别表示每秒接收、发送的网络帧数，也就是  PPS。
 - 第五、六列：rxkB/s 和 txkB/s 分别表示每秒接收、发送的千字节数，也就是  BPS。

发现eth0的上接收网络帧数大，发送网络帧数却小；docker0和veth9f6bbcd合eth0相反

那可能就是eth0网卡上存在接收数据有问题： 计算每个帧数的大小：664.86 * 1024 / 12607 = 54 字节，这明显就是一个小包

4、tcpdump 抓取 eth0 上的包
```text
# -i eth0 只抓取eth0网卡，-n不解析协议名和主机名
# tcp port 80表示只抓取tcp协议并且端口号为80的网络帧
$ tcpdump -i eth0 -n tcp port 80
15:11:32.678966 IP 192.168.0.2.18238 > 192.168.0.30.80: Flags [S], seq 458303614, win 512, length 0
...
```
 - 192.168.0.2.18238 > 192.168.0.30.80，表示网络帧从 192.168.0.2 的 18238 端口发送到 192.168.0.30 的 80 端口，也就是从运行 hping3 机器的 18238 端口发送网络帧，目的为 Nginx 所在机器的 80 端口。
 - Flags [S] 则表示这是一个 SYN 包。

再加上前面用 sar 发现的， PPS 超过 12000 的现象，现在我们可以确认，这就是从 192.168.0.2 这个地址发送过来的 SYN FLOOD 攻击。