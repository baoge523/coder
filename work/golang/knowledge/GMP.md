## golang GMP

G goroutine 协程 任务
M machine   操作系统线程
p processor 处理器

p 管理者一组G，并需要绑定到一个M上

每个p都有自己本地的队列，用于存放G任务， 所有的p同时也会共用一个全局的队列

#### 启动协程：

当go func{} 被执行调度的时候，会创建一个G，该G会优先存放到创建的它的协程对应的p的本地队列中，如果满了，就放到全局队列中去


#### 循环调度：

p绑定了M执行G时，会优先执行p本地队列中的G，如果本地队列空了，那么就去全局队列中获取G，如果全局队列也空了，那么就去查看网络轮询器中是否有准备好的G，如果还没有，那么就窃取其他p中的本地队列中的G

p的本地队列
全局队列
网络轮询器
窃取其他p的本地队列


#### 阻塞时的处理模型：
系统调用阻塞：syscall
  该操作会阻塞 M 和 G， 此时P 会与M解绑，然后找一个空闲的，或者创建一个M并绑定，然后执行队列中的G

select\锁等待阻塞：
  该操作只会阻塞 G，不会阻塞M，所以p会让M执行p中队列中的G，当阻塞的G可执行时，重新放回本地队列中等待被执行


